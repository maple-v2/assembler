הגדרת פרוייקט – ממן 14
חומרת המחשב המוגדר בפרוייקט
1.	כללי
•	המחשב בפרויקט מורכב ממעבד – CPU , רגיסטרים (אוגרים) וזיכרון RAM (חלק מהזיכרון משמש כמחסנית (stack)).
2.	רגיסטרים:
•	למעבד 8 רגיסטרים כלליים בשמות r0, r1, r2, r3, r4, r5, r6, r7. 
•	גודל של כל רגיסטר הוא 10 סיביות .
•	הסיבית הכי פחות משמעותית תצוין כסיבית מס' 0, והסיבית המשמעותית ביותר כמס' 9.
•	PSW – (program status word) רגיסטר בזיכרון שמכיל מספר דגלים המאפיינים את מצב הפעילות במעבד בכל רגע נתון.
3.	זיכרון:
גודל הזיכרון הוא 256 תאים, בכתובות-0-255 (בבסיס עשרוני)
כל תא בגודל של 10 סיביות (בדומה לגודל של הרגיסטרים)
לתא בזיכרון נקרא בשם "מילה" – הסיביות בכל מילה ממוספרות כמו ברגיסטרים.
4.	הערות חשובות נוספות
•	המחשב עובד רק עם מספרים שלמים חיוביים ושליליים – ללא תמיכה במספרים ממשיים
•	האריתמטיקה נעשית בשיטת המשלים ל2 (two's complement)
•	יש תמיכה בתווים שמיוצגים בקוד ASCII 

שפת האסמבלי המוגדרת בפרוייקט
מבנה הוראת מכונה:
o	כל הוראת מכונה במודל שלנו מורכבת מפעולה ואופרנדים. 
o	מספר האופרנדים הוא בין 0 ל-2, בהתאם לסוג הפעולה. 
o	מבחינת התפקיד של כל אופרנד, נבחין בין אופרנד מקור (source) ואופרנד יעד (destination)
o	כל הוראת מכונה מקודדת למספר מילים זיכרון רצופות, החל ממילה אחת ועד למקסימום חמש מילים, בהתאם לשיטת המיעון בה נתון כל אופרנד (ראו פרטים בהמשך).
o	בקובץ הפלט נכלל את קוד המכונה שנבנה באסמבלר, כל מילה תקודד בבסיס הקסאדצימלי (ראו פרטים לגבי קבצי פלט בהמשך).
1.	מבנה המילה הראשונה בהוראה:
6 7 8 9	4 5	2 3	0 1
opcode	מיעון אופרנד מקור	מיעון אופרנד יעד	E,R,A
בכל סוגי הוראות המכונה, המבנה של המילה הראשונה תמיד זהה. מבנה המילה הראשונה בהוראה הוא כדלקמן:





סיביות 1-0 (A,R,E)
•	סיביות אלה מראות את סוג הקידוד: האם הוא מוחלט (Absolute), חיצוני (External) או מצריך מיקום מחדש (Relocatable).
•	סיביות אלה מתווספות רק לקידודים של הוראות (לא של נתונים), וכן מתווספות גם לכל המילים הנוספות שיש לקידודים אלה.
•	עבור כל תא זיכרון המכיל הוראה (ולא נתונים) מופיע בקובץ object מידע עבור תוכנית הקישור – מידע זה ניתן על ידי 2 הסיביות הימניות של הקידוד (שדה הE,R,A) :
1.	האות 'A' (קיצור של absolute) – מציינת שתוכן התא אינו תלוי במקום בזיכרון בו ייטען בפועל קוד המכונה של התכנית בזמן ביצועה (למשל מילה המכילה אופרנד מיידי). במקרה כזה 2 הסיביות הימניות יכילו את הערך 00.
2.	האות 'R' (קיצור של relocateable)  - מציינת שתוכן התא כן תלוי במקום בזיכרון שבו ייטען בפועל קוד המכונה של התכנית בעת ביצועה. לכן יש לעדכן את תוכן התא בשלב הטעינה , על ידי הוספת היסט (offset) מתאים (היסט זה הינו המען בו תטען המילה הראשונה של התוכנית). במקרה כזה 2 הסיביות הימניות יכילו את הערך 10.
3.	האות 'E' (קיצור של external) – מציינת שתוכן התא תלוי בערכו של סמל חיצוני (external) וכי רק הזמן הקישור ניתן יהיה להכניס לתא את הערך המתאים. במקרה כזה 2 הסיביות הימניות יכילו את הערך 01.

סיביות 2-3
סיביות 2–3 מקודדות את מספר שיטת המיעון של אופרנד היעד (destination operand) – ראו לשונית שיטות מיעון.

סיביות 4-5
סיביות 4–5 מקודדות את מספרה של שיטת המיעון של אופרנד המקור (source operand) 
ראו לשונית שיטות מיעון.

שיטות מיעון שונות (סיביות 2-5)
•	בשפה שלנו קיימות ארבע שיטות מיעון, שמספרן הוא בין 0 ל-3.
•	השימוש בשיטות מיעון מצריך קידוד של מילות-מידע נוספות בהוראה, לכל היותר שתי מילים נוספות לכל אופרנד. 
•	אם שיטת המיעון של רק אחד משני האופרנדים דורשת מילות מידע נוספות, אז מילות המידע הנוספות מתייחסות לאופרנד זה.
•	אם שיטות המיעון של שני האופרנדים דורשות מילות מידע נוספות, אז מילות המידע הנוספות הראשונות מתייחסות לאופרנד המקור ומילות המידע הנוספות האחרונות מתייחסות לאופרנד היעד. 
•	ארבע שיטות המיעון הקיימות במכונה שלנו הן:
#	שיטת המיעון	תוכן מילת המידע הנוספת	אופן כתיבת האופרנד	דוגמה
0	מיעון מידי	המילה הנוספת של ההוראה מכילה את האופרנד עצמו, שהוא מספר המיוצג ב־8 סיביות, אליהם מתווספות זוג סיביות של שדה A,R,E	האופרנד מתחיל בתו  ‎# ולאחריו ובצמוד אליו מופיע מספר שלם בבסיס עשרוני	mov #-1,r2
בדוגמה זו האופרנד הראשון של הפקודה נתון בשיטת מיעון מיידי. הפקודה כותבת
את הערך ‎-1 לתוך אוגר r2
1	מיעון ישיר	המילה הנוספת של ההוראה מכילה מען של מילה בזיכרון. מילה זו בזיכרון היא האופרנד. המען מיוצג ב־8 סיביות אליהן מתווספות זוג סיביות של שדה  A,R,E	האופרנד הינו תווית שהוצהרה או תיווצר בהמשך הקובץ. ההצהרה נעשית על ידי כתיבת תווית בקובץ המקור (בהנחיית  .dataאו .string או .mat או בתחילת הוראה של התוכנית), או על ידי אופרנד של תווית extern.	dec x
בדוגמה זו, תוכן המילה
שבכתובת x בזיכרון
(ה״משתנה״ (x מוקטן
ב־1
2	מיעון גישה למטריצה	האופרנד הוא אוגר. אם האוגר משמש כאופרנד יעד, מילה נוספת של הפקודה תכיל בארבע הסיביות2–5  את מספר של האוגר. אם האוגר משמש כאופרנד מקור, הוא יקודד במילה נוספת שתכיל בששת הסיביות 6–9 את מספרו של האוגר. אם בפקודה יש שני אופרנדים ושניהם אוגרים, הם יחלקו מילה נוספת אחת משותפת. כאשר הסיביות 2–5 הן עבור אוגר היעד, והסיביות 6-9 הן עבור אוגר המקור.
לייצוג זה מתווספות זוג סיביות של שדה A,R,E. סיביות שאינן בשימוש יקבלו 0.
	האופרנד מורכב משם של תווית המציינת מטריצה, ולאחריה שורה ועמודה  במטריצה המצוינים ע"י אוגרים בלבד, ורשומים כל אחד בסוגריים מרובעות.	add #4, a[r2][r5]
בדוגמה זו, הפקודה
מוסיפה את הערך 4
לתא במטריצה שנמצאת
בתווית .a התא הוא
בשורה המצוינת ע"י
תוכן האוגר r2 ובעמודה
המצוינת ע"י תוכן
האוגר r5 

3	מיעון אוגר ישיר 	האופרנד הוא אוגר. 
אם האוגר משמש כאופרנד יעד, מילה נוספת של הפקודה תכיל בארבע הסיביות 2-5 את מספרו של האוגר. 
אם האוגר משמש כאופרנד מקור – הוא יקודד במילה נוספת שתכיל בששת הסיביות 6-9 את מספרו של האוגר.
אם בפקודה יש שני אופרנדים ושניהם אוגרים – הם יחלקו מילה נוספת אחת משותפת, כאשר הסיביות 2-5 הן עבור אוגר היעד, והסיביות 6-9 הן עבור אוגר המקור. לייצוג זה מתווספות זוג סיביות של שדה A,R,E, וסיביות שאינן בשימוש יכילו 0.	האופרנד הינו שם של אוגר	move r1,r2
בדוגמה זו –
אופרנד המקור הוא האוגר r1 ואופרנד היעד הוא האוגר r2. הפקודה מעתיקה את תוכן האוגר r1 לתוך אוגר r2.
בדוגמה זו שני האופרנדים יקודדו למילה משותפת.

סיביות 6-9 
סיביות 6-9 במילה הראשונה של הפקודה מורות את קוד ההוראה (opcode) 
בשפה שלנו יש 16 קודי הוראה והם:
קוד בבסיס עשרוניopcode 	פעולה
0	mov
1	cmp
2	Add
3	Sub
4	Not
5	Clr
6	Lea
7	Inc
8	Dec
9	Jmp
10	Bne
11	Red
12	Prn
13	Jsr
14	Rts
15	stop

הוראות נכתבות תמיד באותיות קטנות. פירוט משמעות ההוראות בלשונית "חלוקת ההוראות לקבוצות"

מפרט הוראות מכונה:
1.	בביצוע הוראות המכונה נעשה שימוש במונה PC (קיצור של"Program Counter" )
2.	זהו רגיסטר פנימי של המעבד (לא רגיסטר כללי), שמכיל בכל רגע נתון את כתובת הזיכרון בה נמצאת ההוראה הנוכחית שמבוצעת (הכוונה תמיד לכתובת המילה הראשונה של ההוראה)
3.	הוראות המכונה מתחלקות לשלוש קבוצות, לפי מספר האופרנדים הדרוש לפעולה.
חלוקת ההוראות לקבוצות:
1.	קבוצת ההוראות הראשונה: אלו הן הוראות הדורשות שני אופרנדים.
ההוראות השייכות לקבוצה זו הן: mov, cmp, add, sub, lea
הוראה	Opcode	הפעולה המתבצעת	דוגמה	הסבר הדוגמה
mov	0	מבצעת העתקה של תוכן אופרנד המקור (האופרנד הראשון) אל אופרנד היעד (האופרנד השני)	mov r1,r2	העתק את תוכן המשתנה A (המילה שבכתובת A בזיכרון( אל רגיסטר r1
cmp	1	מבצעת השוואה בין שני האופרנדים. ערך אופרנד היעד (השני) מופחת מערך אופרנד המקור (הראשון), ללא שמירת תוצאת החיסור. פעולת החיסור מעודכנת בדגל בשם Z ("דגל האפס") ברגיסטר הסטטוס (PSW)	cmp A, r1	אם תוכן המשתנה A  זהה לתוכנו של הרגיסטר r1 אז הדגל Z ("דגל האפס") ברגיסטר הסטטוס (PSW)  יודלק (1), אחרת הדגל יכבה. (0) 
add	2	אופרנד היעד (השני) מקבל את תוצאת החיבור של אופרנד המקור (הראשון) והיעד (השני).	add A, r0	רגיסטר r0 מקבל את תוצאת
החיבור של תוכן המשתנה  A
ותוכנו הנוכחי של r0 
sub	3	אופרנד היעד (השני) מקבל את תוצאת החיסור של אופרנד המקור (הראשון) מאופרנד היעד.	sub #3, r1	רגיסטר r1 מקבל את תוצאת
החיסור של הקבוע 3 מתוכנו
הנוכחי של הרגיסטר r1 
lea	6	lea  הוא קיצור (ראשי תיבות) של
load effective address  פעולה
זו מציבה את המען בזיכרון
המיוצג על ידי התווית שבאופרנד
המקור (הראשון), אל אופרנד
היעד (האופרנד השני).	lea HELLO, r1	המען שמייצגת התווית
HELLO  מוצב לרגיסטר r1



2.	קבוצת ההוראות השנייה:
1.	אלו הן הוראות הדורשות אופרנד אחד בלבד. אופן הקידוד של האופרנד הוא כמו של אופרנד היעד בפקודה עם שני אופרנדים. 
2.	השדות של אופרנד המקור (סיביות 4–5) במילה הראשונה בקידוד ההוראה אינם בשימוש, ולפיכך יהיו מאופסים.
3.	ההוראות השייכות לקבוצה זו הן: clr, not, inc, dec, jmp, bne, jsr, red, prn
הוראה	Opcode	הפעולה המתבצעת	דוגמה	הסבר הדוגמה
clr	5	איפוס תוכן האופרנד	clr r2	הרגיסטר r2 מקבל את הערך 0
not	4	היפוך ערכי הסיביות באופרנד (כל סיבית שערכה 0 תהפוך ל-1 ולהיפך)	not r2	כל ביט בr2 מתהפך
inc	7	הגדלת תוכן האופרנד ב1	Inc r2	תוכן הרגיסטר r2 מוגדל ב1
dec	8	הקטנת תוכן האופרנד ב1	dec count	תוכן המשתנה count מוקטן ב1
jmp	9	קפיצה (הסתעפות) בלתי מותנית אל ההוראה שנמצאת במען המיוצג על ידי האופרנד. כלומר, כתוצאה מביצוע ההוראה, מצביע התוכנית (PC) מקבל את ערך אופרנד היעד	jmp line	PC מקבל את הערך של line
bne	10	קיצור של branch if not equal (to zero)
זוהי הוראת הסתעפות מותנית.
אם ערכו של הדגל Z ברגיסטר הסטטוס (PSW) הינו 0, אזי מצביע התוכנית (PC), מקבל את יעד הקפיצה. כזכור הדגל Z נקבע באמצעות ההוראה cmp	bne line	אם ערך הדגל ברגיסטר הסטטוס (PC) הוא 0 , אז PC יקבל את הערך של line
jsr	13	קריאה לשגרה (סברוטינה).
כתובת ההוראה שאחרי הוראת jsr הנוכחית (PC+2) נדחפת לתוך המחסנית שבזיכרון המחשב, ומצביע התוכנית (PC) מקבל את כתובת השגרה. 
הערה: חזרה מהשגרה מתבצעת באמצעות הוראת rts תוך שימוש בכתובת שבמחסנית	jsr SUBR	Push(PC+2)
PC  address(SUBR)
מצביע התוכנית יקבל את כתובת התווית SUBR, ולפיכך ההוראה הבאה שתתבצע תהיה במען SUBR.
כתובת החזהר מהשגרה נשמרת במחסנית
red	11	קריאה של תו מהקלט הסטנדרטי (stdin) אל האופרנד	red r1	קוד ה ASCII של התו הנקרא מהקלט ייכנס לרגיסטר r1
prn	12	יודפס לפלט התו (קוד ASCII) הנמצא ברגיסטר r1	prn r1	יודפס לפלט התו (קוד ASCII) הנמצא ברגיסטר r1

3.	קבוצת ההוראות השלישית:
•	אלו הן הוראות ללא אופרנדים. 
•	קידוד ההוראה מורכב ממילה אחת בלבד. השדות של אופרנד המקור ושל אופרנד היעד (סיביות 2-5) במילה הראשונה של קידוד ההוראה אינם בשימוש, ולפיכך יהיו מאופסים.
•	ההוראות השייכות לקבוצה זו הן: stop, rts 
הוראה	Opcode	הפעולה המתבצעת	דוגמה	הסבר הדוגמה
	rts	14	מתבצעת חזרה משגרה. הערך שבראש המחסנית של המחשב מוצא מן המחסנית, ומוכנס למצביע התוכנית (PC)
הערה :  ערך זה נכנס למחסנית בקריאה לשגרה ע"י הוראת jsr 	Rts	PC  pop()
ההוראה הבאה שתתבצע תהיה זו שאחרי הוראת jsr שקראה לשגרה
stp	15	עצירת ריצת התוכנית	Stop	התוכנית עוצרת מיידית


הגדרת בסיס 4 הייחודי :
•	קידוד כל מילה בקוד המכונה נעשה בבסיס 4 "ייחודי" המוגדר כדלקמן: 
•	ארבע הספרות הן  a,b,c,d (כאשר a שקול ל0, b שקול ל1, c שקול ל2, d שקול ל3).
•	קידוד של מילה בגודל 10 סיביות בבסיס 4 מורכב מחמש ספרות (עם ספרות a מובילות לפי הצורך).

מבנה כללי של שפת האסמבלי:
תכנית בשפת האסמבלי בנויה ממאקרואים ומשפטים (statements)
מאקרואים:
•	בתוכנית ניתן להגדיר מאקרו ולהשתמש בו במקומות שונים בתוכנית. 
•	השימוש במאקרו ממקום מסוים בתוכנית יגרום לפרישת המאקרו לאותו מקום.
•	הגדרת מאקרו נעשית באופן הבא: (בדוגמה שם המאקרו הוא a_mc):
mcro a_mc
    inc r2
    mov A, r1
mcrend
•	שימוש במאקרו הוא פשוט אזכור שמו. למשל אם בתוכנית במקום מסויים כתוב:
.
.
a_mc
.
.
a_mc
.
.

התוכנית לאחר פרישת המאקרו תראה כך: (בדוגמה זו השתמשנו במאקרו פעמיים)

.
    inc r2
    mov A, r1
.
    inc r2
    mov A, r1
.

•	התוכנית לאחר פרישת המאקרו היא התוכנית שהאסמבלר אמור לתרגם.
•	הנחות והנחיות לגבי מאקרו:
o	אין במערכת הגדרות מאקרו מקוננות (אין צורך לבדוק זאת).
o	שם של הוראה או הנחיה לא יכול לשמש שם של מאקרו (יש לבדוק זאת).
o	ניתן להניח שכל הופעה של שם מאקרו בקוד המקור קיימת סגירה עם שורת mcroend  (אין צורך לבדוק זאת)
o	הגדרת מאקרו תהיה תמיד  לפני הקריאה למאקרו (אין צורך לבדוק זאת).
o	נדרש שהקדם־אסמבלר ייצור קובץ עם הקוד המורחב הכולל פרישה של המאקרו (הרחבה של קובץ המקור המתואר בהמשך). 
o	"קובץ המקור המורחב" (עם סיומת .am) הוא "קובץ מקור" לאחר פרישת המאקרו, לעומת "קובץ מקור ראשוני" (עם סיומת .as) שהוא קובץ הקלט למערכת, כולל הגדרת המאקרואים.
•	לסיכום, במאקרו יש לבדוק:
1.	שם המאקרו תקין (אינו שם הוראה וכדומֶה)
2.	בשורת ההגדרה ובשורת הסיום אין תווים נוספים
3.	אם נמצאה שגיאה בשלב פרישת המאקרו – אי אפשר לעבור לשלבִים הבאים.
יש לעצור, להודיע על השגיאות ולעבור לקובץ המקור הבא (אם קיים).
הערה:  גילוי שגיאות בגוף המאקרו (אם יש) יקרה בשלבים הבאים

משפטים:
1.	קובץ מקור בשפת אסמבלי מורכב משורות המכילות משפטים של השפה, כאשר כל משפט מופיע בשורה נפרדת. 
2.	ההפרדה בין משפטים בקובץ המקור תהֵיה באמצעות התו'\n'  (שורה חדשה)
3.	אורכה של שורה בקובץ המקור הוא 80 תווים לכל היותר (לא כולל התו( '\n' 
4.	אם השורה ארוכה מ־ 80 תווים, יש לדווח על שגיאה.
סוגי משפטים בשפת האסמבלי:
1.	משפט ריק –
זוהי שורה המכילה אך ורק תווים לבנים (whitespace) , כלומר , רק את התווים ' ' ו- '\t' (רווחים וטאבים). ייתכן גם ובשורה אין אף תו (למעט התו \n) , כלומר השורה ריקה.

2.	משפט הערה – 
זוהי שורה בה התו הראשון הינו ; (נקודה פסיק), ועל האסמבלר להתעלם לחלוטין משורה זו.

3.	משפט הנחיה – 
1.	זהו משפט המנחה את האסמבלר מה עליו לעשות שהוא פועל על תוכנית המקור. 
2.	יש מספר סוגים של משפטי הנחיה. 
3.	משפט הנחיה עשוי לגרום להקצאת זיכרון ואתחול משתנים של התוכנית, אך הוא אינו מייצר קידוד של הוראות מכונה המיועדות לביצוע בעת ריצת התוכנית
4.	משפט הנחיה הוא בעל המבנה הבא: 
1.	בתחילת המשפט יכולה להופיע הגדרה של תווית (label) לתווית יש תחביר חוקי שיתואר בהמשך. התווית היא אופציונלית
2.	לאחר מכן באמצע המשפט מופיע שם ההנחיה
3.	לאחר שם ההנחיה יופיעו פרמטרים (מספר הפרמטרים בהתאם להנחיה)
4.	שם של הנחיה מתחיל בתו '.' (נקודה) ולאחריו תווים באותיות קטנות (lower case) בלבד.
5.	יש לשים לב: למילים בקוד המכונה הנוצרות ממשפטי הנחיה לא מצורף השדה A,E,R והקידוד ממלא את כל הסיביות של המילה.
5.	יש ארבעה סוגים של משפטי הנחיה והם:
1.	ההנחיה .data – 
1.	הפרמטרים של ההנחיה הם מספרים שלמים חוקיים (אחד או יותר) המופרדים על ידי התו ',' (פסיק), לדוגמה: .data 7,-57,+17,9 
2.	יש לשים לב שהפסיקים אינם חייבים להיות צמודים למספרים
3.	בין מספר לפסיק ובין פסיק למספר יכולים להופיע רווחים וטאבים בכל כמות (או בכלל לא), אולם הפסיק חייב להופיע בין המספרים. 
4.	כמו כן, אסור שיופיע יותר מפסיק אחד בין שני מספרים, וגם לא פסיק אחרי המספר האחרון או לפני המספר הראשון.
5.	המשפט data.  מנחה את האסמבלר להקצות מקום בתמונת הנתונים (data image) אשר בו יאוחסנו הערכים של הפרמטרים, ולקדם את מונה הנתונים בהתאם למספר הערכים. 
6.	אם בתחילת data.  מוגדרת תווית, אז תווית זו מקבלת את ערך מונה הנתונים (לפני הקידום), ומתווספת אל טבלת הסמלים. דבר זה מאפשר להתייחס אל מקום מסוים בתמונת הנתונים דרך שם התווית (למשל, זוהי דרך להגדיר שם של משתנה).
7.	דוגמה: אם נכתוב XYZ: .data 7, -57, +17, 9
אז יוקצו בתמונת הנתונים ארבע מילים רצופות שיכילו את המספרים שמופיעים בהנחיה. התווית XYZ מזוהה עם כתובת המילה הראשונה.
8.	דוגמה נוספת: אם נכתוב בתוכנית את ההוראה mov XYZ, r1 אז בזמן ריצת התוכנית יוכנס לרגיסטר r1 הערך 7.
9.	דוגמה נוספת:  ההוראה lea XYZ, r1 תכניס לרגיסטר r1 את ערך התווית XYZ (כלומר, הכתובת בזיכרון בה מאוחסן הערך 7).

2.	ההנחיה '.string' :
1.	להוראה ‘.string’ פרמטר אחד, שהוא מחרוזת חוקית. 
2.	תווי המחרוזת מקודדים לפי ערכי ה־ASCII  המתאימים, ומוכנסים אל תמונת הנתונים לפי סדרם, כל תו במילה נפרדת. 
3.	בסוף המחרוזת יתווסף תו ה־‘\0’ (הערך המספרי 0), המסמן את סוף המחרוזת. 
4.	מונה הנתונים של האסמבלר יקודם בהתאם לאורך המחרוזת (בתוספת מקום אחד עבור התו המסיים). 
5.	אם בשורת ההנחיה מוגדרת תווית, אזי תווית זו מקבלת את ערך מונה הנתונים (לפני הקידום) ומוכנסת אל טבלת הסמלים, בדומה למה שנעשה עבור ‘.data’  (כלומר ערך התווית יהיה הכתובת בזיכרון שבה מתחילה המחרוזת)
6.	לדוגמה: STR: .string "abcdef"
מקצה בתמונת הנתונים רצף של 7 מילים, ומאתחלת את המילים לקודי ה־ascii  של התווים לפי הסדר במחרוזת, ולאחריהם הערך 0 לסימון סוף מחרוזת. התווית STR מזוהה עם כתובת התחלת המחרוזת.

3.	ההנחיה  .mat:
1.	משפט הנחיה זה מקצה מטריצה.
2.	למשפט הנחיה זה המבנה הבא:   
MAT8: .mat [2][3] 
MAT5: .mat [2][2] 4,-5,7,9
3.	בדוגמה הראשונה מקצים מטריצה בשם  MAT8 שגודלה 2 שורות ו3 עמודות והיא אינה מאותחלת בערכים (אבל כן צורכת מקום בתמונת הנתונים).
4.	בדוגמה השנייה מקצים מטריצה בשם MAT5  בגודל 2 שורות ו־2 עמודות, המאותחלת לערכים המפורטים. הערכים לאתחול רשומים משמאל לימין לפי סדר השורות. מטריצה תחיל רק מספרים שלמים.

4.	ההנחיה .entry :
1.	להנחיה  .entryפרמטר והוא שם של תווית המוגדרת בקובץ המקור הנוכחי (כלומר תווית שמקבלת את ערכה בקובץ זה). 
2.	מטרת ההנחיה .entry היא לאפיין את התווית הזו באופן שיאפשר לקוד אסמבלי הנמצא בקבצי מקור אחרים להשתמש בה (כאופרנד של הוראה).
3.	לדוגמה השורות:
.entry Hello
HELLO: add #1, r1
מודיעות לאסמבלר שאפשר להתייחס בקובץ אחר לתווית HELLO המוגדרת בקובץ הנוכחי.
4.	לתשומת לב: תווית המוגדרת בתחילת שורת .entry הינה חסרת משמעות והאסמבלר מתעלם מתווית זו (האסמבלר יוציא הודעת אזהרה)
5.	ההנחיה .extern
1.	להנחיה .extern  פרמטר שהוא שם של תווית שאינה מוגדרת בקובץ המקור הנוכחי. 
2.	מטרת ההנחיה היא להודיע לאסמבלר כי התווית מוגדרת בקובץ מקור אחר, וכי קוד האסמבלי בקובץ הנוכחי עושה בתווית שימוש.
3.	נשים לב כי הנחיה זו תואמת להנחיה .entry המופיעה בקובץ בו מוגדרת התווית. 
4.	בשלב הקישור תתבצע התאמה בין ערך התווית, כפי שנקבע בקוד המכונה של הקובץ שהגדיר את התווית, לבין קידוד ההוראות המשתמשות בתווית בקבצים אחרים (שלב הקישור לא רלוונטי למטלה זו)
5.	לדוגמה: משפט ההנחיה .extern  תואם למשפט ההנחיה .entry. מהדוגמה הקודמת יהיה: .extern HELLO
6.	הערה:  לא ניתן להגדיר באותו הקובץ את אותה התווית גם כ־.entry  וגם כ .extern –(בדוגמאות לעיל, התווית (HELLO. במקרה כזה יש להודיע על שגיאה.
7.	לתשומת לב: תווית המוגדרת בתחילת שורת .extern  הינה חסרת משמעות והאסמבלר מתעלם מתווית זו (אף אפשר שהאסמבלר יוציא הודעת אזהרה).

4.	משפט הוראה – 
זהו משפט המייצר קידוד של הוראות מכונה לביצוע בעת ריצת התוכנית. המשפט מורכב משם של הוראה שעל המעבד לבצע, ותיאור האופרנדים של ההוראה.
1.	משפט הוראה מורכב מהחלקים הבאים:
1.	תווית אופציונלית.
2.	שם הפעולה.
3.	אופרנדים, בהתאם לסוג הפעולה (בין 0 ל־2 אופרנדים).
2.	אם מוגדרת תווית בשורת ההוראה, אזי היא תוכנס אל טבלת הסמלים. ערך התווית יהיה מען המילה הראשונה של ההוראה בתוך תמונת הקוד שבונה האסמבלר.
3.	שם הפעולה תמיד באותיות קטנות (lower case), והוא אחת מ־16 הפעולות שפורטו לעיל.
4.	לאחר שם הפעולה יופיעו האופרנדים, בהתאם לסוג הפעולה. יש להפריד בין שם-הפעולה לבין האופרנד הראשון באמצעות רווח / טאב (אחד או יותר).
5.	כאשר יש שני אופרנדים, האופרנדים מופרדים זה מזה בתו ',' (פסיק) בדומה להנחייה .data 
6.	לא חייבת להיות הצמדה של האופרנדים לפסיק. כל כמות של רווחים או טאבים משני צידי הפסיק היא חוקית.
7.	למשפט הוראה עם שני אופרנדים תינתן הצורה הבאה:
8.	למשפט הוראה עם שני אופרנדים המבנה הבא: 
label: opcode source-operand, target-operand
לדוגמה : HELLO:        add   r7, B
9.	למשפט הוראה עם אופרנד אחד המבנה הבא:
label: opcode target-operand
לדוגמה: HELLO:        bne   XYZ
10.	למשפט הוראה ללא אופרנדים המבנה הבא: label: opcode
לדוגמה: END:          stop

אפיון השדות במשפטים של שפת האסמבלי
1.	תווית:
1.	בתיאור שיטות המיון למעלה הסברנו כי תווית היא ייצוג סימבולי של כתובת בזיכרון. נרחיב כאן את ההסבר:
2.	תווית היא למעשה סמל שמוגדר בתחילת משפט הוראה, או בתחילת הנחיית .data או .string.
3.	תווית חוקית מתחילה באות אלפביתית (גדולה או קטנה), ולאחריה סדרה כלשהי של אותיות אלפביתיות (גדולות או קטנות) ו/או ספרות. האורך המקסימלי של תווית הוא 30 תווים.
4.	הגדרה של תווית מסתיימת בתו ‘:’ (נקודתיים). תו זה אינו מהווה חלק מהתווית, אלא רק סימן המצביע את סוף ההגדרה. התו ‘:’ חייב להיות צמוד לתווית (ללא רווחים).
5.	אסור שאותה תווית תוגדר יותר מפעם אחת (כמובן בשורות שונות). אותיות קטנות וגדולות נחשבות שונות זו מזו.
6.	לדוגמה, התוויות המוגדרות להלן הן תוויות חוקיות:
hEllo:
X:
He78902:
7.	לתשומת לב: מילים שמורות של שפת האסמבלי (כלומר שם של פעולה או הנחיה, או שם של רגיסטר) אינן יכולות לשמש גם כשם של תווית. כמו כן, אסור שאותו סמל ישמש הן כתווית והן כשם של מאקרו (יש לבדוק זאת).
8.	התווית מקבלת את ערכה בהתאם להקשר בו היא מוגדרת. תווית המוגדרת בתחילת הנחיית .data, .string, או  .mat תקבל את ערך מונה הנתונים (data counter) הנוכחי, בעוד שתווית המוגדרת בשורת הוראה תקבל את ערך מונה ההוראותinstruction) counter ) הנוכחי.
9.	לתשומת לב: מותר במשפט הוראה להשתמש באופרנד שהוא סמל שאינו מוגדר כתווית בקובץ הנוכחי, כל עוד הסמל מופיע כרשמי (באמצעות הנחיית .extern,  כלשהי בקובץ הנוכחי)

2.	מספר:
1.	מספר חוקי מתחיל בסימן אופציונלי: ‘־’ או ‘+’ ולאחריו סדרה כלשהי של ספרות בבסיס עשרוני.
2.	לדוגמה ‎76, ‎-5, ‎+123 :הם מספרים חוקיים. 
3.	אין תמיכה בשפת האסמבלי שלנו בייצוג בבסיס אחר מאשר עשרוני, ואין תמיכה במספרים שאינם שלמים.

3.	מחרוזת:
1.	מחרוזת חוקית היא סדרת תווי ascii נראים (שניתנים להדפסה), המוקפים בגרשיים כפולים (הגרשיים אינם נחשבות חלק מהמחרוזת). 
2.	דוגמה למחרוזת חוקית: "hello world"
תזכורת: סימון המילים בקוד המכונה של הוראה באמצעות המאפיין  “A,R,E”

1.	בכל מילה בקוד המכונה של הוראה (לא של נתונים), האסמבלר מכניס מידע עבור תהליך הקישור והטעינה - זהו השדה A,R,E. 
2.	המידע ישמש לתיקונים בקוד בכל פעם שייטען לזכרון לצורך הרצה
3.	האסמבלר בונה מלכתחילה קוד שמיועד לטעינה החל מכתובת ההתחלה. התיקונים מאפשרים לטעון את הקוד בכל פעם למקום אחר, בלי צורך לחזור על תהליך האסמבלי
4.	שלוש הסיביות בשדה A,R,E יכולות להכיל ערכים בינאריים כפי שהוסבר בתיאור שיטות המיעון. 
5.	המשמעות של כל ערך מפורטת להלן:
1.	האות ‘A’ (קיצור של (absolute באה לציין שתוכן המילה אינו תלוי במקום בזיכרון בו יתבצע בפועל קוד המכונה של התוכנית בעת ביצועה (למשל- מילה המכילה אופרנד מידי).
2.	האות ‘R’ (קיצור של (relocatable באה לציין שתוכן המילה אינו תלוי במקום בזיכרון בו ייטען בפועל קוד המכונה של התוכנית בעת ביצועה (למשל – מילה המכילה כתובת של תווית המוגדרת בקובץ המקור)
3.	האות ‘E’ (קיצור של (external באה לציין שתוכן המילה תלוי בערכו של סמל חיצוני (external)  (למשל המכילה כתובת של תווית חיצונית, כלומר תווית שאינה מוגדרת בקובץ המקור)

האסמבלר
דרך עבודת האסמבלר:
•	כאשר האסמבלר מקבל כקלט תוכנית בשפת אסמבלי, עליו לטפל תחילה בפרישת המאקרואים, ורק לאחר מכן לעבור על התוכנית אליה נפרשו המאקרואים. 
•	כלומר, פרישת המאקרואים תעשה בשלב "קדם אסמבלר"
•	לאחר פרישת המאקרואים, האסמבלר ייצר קובץ "פרוש" בעל סיומת .am במידה ואין צורך לפרוש מקרואים, הקובץ הפרוש (.am) יהיה זהה לקובץ המקור (.as)
•	במעבר הראשוני של האסמבלר, יש לזהות את הסמלים (תוויות) המופיעים בתוכנית, ולתת לכל סמל ערך מספרי שהוא המען בזיכרון שהסמל מייצג. 
•	במעבר השני, באמצעות ערכי הסמלים, וכן קוד־הפעולה ומספרי האופרנדים, בונים את קוד המכונה. שם, עלינו להחליף את שמות הפעולות בקוד הבינארי השקול להם במודל המחשב שהוגדר.
•	כמו כן, על האסמבלר להחליף את כל הסמלים (למשל (MAIN, LOOP במענים של המקומות בזיכרון שם נמצאים כל נתון או הוראה בהתאמה.
פירוט על אופן פעולת האסמבלר:
מערך הנתונים ומערך ההוראות:
•	האסמבלר מחולק לשני מערכים, שייקראו להלן מערך הוראות ומערך הנתונים. מערכים אלו נותנים מעשה תמונה של זיכרון המכונה. גודל כל כניסה במערך זהה לגודלה של מילת מכונה (בסיביות)
•	במערך ההוראות מכניס האסמבלר את הקידוד של הוראות המכונה שנקראו במהלך המעבר על קובץ המקור.
•	במערך הנתונים מכניס האסמבלר את קידוד הנתונים שנקראו מקובץ המקור (שורות מסוג .data, .string).
•	לאסמבלר יש שני מונים: מונה ההוראות (IC) ומונה הנתונים .(DC) מונים אלו מצביעים על המקום הבא הפנוי במערכים לעיל, בהתאמה. כשמתחיל האסמבלר לעבור על קובץ המקור, שני מונים אלה מקבלים ערך התחלתי.
טבלת הסמלים:
•	בנוסף, לאסמבלר יש טבלה אשר בה נאספות כל התוויות בהן נתקל האסמבלר במהלך המעבר על הקובץ. לטבלה זו קוראים טבלת סמלים (symbol table).
•	לכל סמל (תווית) נשמרים שמו, ערכו, ומאפיינים שונים (כמו המיקום (data/code) או אופן העדכון (למשל extern) 
שיטת קידוד קובץ המקור:
•	האסמבלר קורא את קובץ המקור שורה אחר שורה, מחליט מהו סוג השורה (הערה, הוראה, הנחיה או שורה ריקה) ופועל בהתאם:
1.	עבור שורה ריקה או שורת הערה:
	האסמבלר מתעלם מהשורה ועובר לשורה הבאה.
2.	עבור שורת הוראה: 
1.	האסמבלר מוצא מהי הפעולה ומהן שיטות המיעון של האופרנדים (מספר האופרנדים אותם הוא מחפש נקבע בהתאם להוראה הוא מצא)
2.	אם האסמבלר מוצא בשורת ההוראה גם הגדרה של תווית, אזי התווית מוכנסת אל טבלת הסמלים (ערך התווית יהיה הערך של IC, והמאפיין הוא code)
3.	האסמבלר קובע לכל אופרנד את ערכו באופן הבא:
	אם זה רגיסטר – האופרנד הוא מספר הרגיסטר
	אם זו תווית (מיעון ישיר) – האופרנד הוא ערך התווית כפי שמופיע בטבלת הסמלים (ייתכן והסמל טרם נמצא בטבלת הסמלים)
	אם זה התו # ואחריו מספר – האופרנד הוא המספר עצמו
	אם זו שיטת מיעון אחרת – ערכו של האופרנד נקבע לפי המפרט של שיטת המיעון (ראו טבלת תיאור שיטות המיעון). קביעת שיטת המיעון נעשית בהתאם לתחביר של האופרנד (כפי שהוסבר בהגדרת שיטות המיעון – למשל מספר מציין מיעון מיידי, תווית מציינת מיעון ישיר וכו')
4.	אם זוהי פעולה בעלת אופרנד אחד בלבד (כלומר אין אופרנד מקור), אז הקידוד זהה לעיל פרט לסיביות של שיטת המיעון של אופרנד המקור במילה הראשונה אשר יכילו תמיד 0, מכיוון שאינן רלוונטיות לפעולה.
5.	אם זוהי פעולה ללא אופרנדים אז תקודד רק המילה הראשונה (והיחידה). הסיביות של שיטות המיעון של האופרנדים יכילו 0.
3.	עבור שורת הנחיה: 
כאשר האסמבלר קורא בקובץ המקור שורת הנחיה, הוא פועל בהתאם לסוג ההנחייה באופן הבא:
.data 
	האסמבלר קורא את רשימת המספרים, המופיעה לאחר .data , ומכניס כל מספר אל מערך הנתונים. 
	לאחר מכן מקדם את מצביע הנתונים DC באחד עבור כל מספר שהוכנס. 
	אם בשורה .data יש תווית , אז תווית זו מוכנסת לטבלת הסמלים. היא מקבלת את הערך של מונה הנתונים DC (כלומר את הערך של DC ולפני הכנסת המספרים למערך הנתונים). כן מסומן שההגדרה ניתנה בחלק הנתונים.
.mat 
	האסמבלר קורא את רשימת המספרים של אתחול המטריצה (אם ישנו), ומכניס כל מספר שנקרא אל מערך הנתונים. 
	לאחר מכן מקדם את מצביע הנתונים (DC) באחד עבור כל מספר שהוכנס. 
	אם המטריצה אינה מאותחלת בערכים, יוקצו תאים במערך בהתאם לגודל המטריצה, והם יאותחלו ב0. 
	הטיפול בתווית המופיעה בשורה זהה לטיפול הנעשה בהנחיה .data
.string 
	הטיפול ב.string דומה ל.data אלא שקודי הascii -  של התווים הם אלו שמוכנסים אל מערך הנתונים (כל תו בכניסה נפרדת). 
	לאחר מכן מוכנס הערך 0 (המציין סוף מחרוזת) אל מערך הנתונים. 
	מונה הנתונים מקודם באורך המחרוזת פלוס 1 (תו האפס שמוכנס מלאכותית בסוף המחרוזת).
	הטיפול בתווית המוגדרת בשורה זו זהה לטיפול הנעשה בהנחיה .data
.entry 
	זוהי בקשה לאסמבלר להכניס את התווית המופיעה באופרנד של .entry אל קובץ הentries. האסמבלר רושם את הבקשה ובסיום העבודה, התווית הנ"ל תירשם בקובץ הentries
.extern 
	זוהי הצהרה על סמל (תווית) המוגדר בקובץ אחר, ואשר קטע האסמבלי בקובץ הנוכחי עושה בו שימוש. האסמבלר מכניס את הסמל אל טבלת הסמלים. ערכו הוא 0 (הערך האמיתי לא ידוע וייקבע רק בשלב הקישור – שלא כלול במטלה זו) וטיפוסו הוא external. לא ידוע באיזה קובץ נמצאת הגדרת הסמל (וגם אין זה משנה עבור האסמבלר).

יש לשים לב :  
•	בהוראה או בהנחיה אפשר להשתמש בשם של סמל אשר ההצהרה עליו ניתנת בהמשך הקובץ (גם באופן ישיר על ידי הגדרת תווית, ואם באופן עקיף על ידי הנחיית extern)
•	בסוף המעבר הראשון  האסמבלר מעדכן בטבלת הסמלים כל סמל המאופיין כ- data על ידי הוספת IC+100 (עשרוני) לערכו של הסמל. 
•	הסיבה לכך היא שבתמונה הכוללת של קוד המכונה, הנתונים מופרדים מההוראות, וכל הנתונים נדרשים להופיע אחרי כל ההוראות. 
•	סמל מסוג data הוא למעשה תווית באזור הנתונים, והעדכון מוסיף לערך הסמל (כלומר לכתובתו בזיכרון) את האורך הכולל של קידוד כל ההוראות, בתוספת כתובת התחלת הטעינה של הקוד, שהיא 100.
•	לאחר  המעבר הראשון, טבלת הסמלים מכילה כעת את כל הערכים הנחוצים להשלמת הקידוד (למעט ערכים של סמלים חיצוניים). 
•	במעבר השני האסמבלר מקודד באמצעות טבלת הסמלים את כל המילים במערך ההוראות שטרם קודדו במעבר הראשון. אלו הן מילים שצריכות להכיל כתובות של תוויות.
•	כעת נדגים לעומק את כלל השלבים:

קדם אסמבלר - שלב פרישת המקרואים
דוגמה לשלב קדם אסמבלר:
1.	האסמבלר מקבל את התוכנית הבאה בשפת אסמבלי:
MAIN:      	mov   M1[r2][r7], LENGTH
     	    	add   r2, STR
LOOP:    	jmp   END
         	   	prn   #-5
  	 	mcro  a_mc
  	 	mov   M1[r3][r3], r3
 	bne   LOOP
         		mcrend
         		sub   r1, r4
         		inc   K
END:   		a_mc
         		stop
STR:		.string "abcdef"
LENGTH:  	.data 6, -9, 15
K: 	          	.data 22
M1:      		.mat [2][2] 1, 2, 3, 4

1.	תחילה האסמבלר עובר על התוכנית ופורש את כל המקרואים הקיימים בה. רק אם תהליך זה מסתיים בהצלחה, ניתן לעבור לשלב הבא, אחרת, יש להציג את השגיאות ולא לייצר קבצים.
2.	בדוגמה זו התוכנית לאחר פרישת המקרואים תיראה כך:
MAIN:    	mov   M1[r2][r7], LENGTH
         	add   r2, STR
LOOP:    	jmp   END
         	prn   #-5
         	sub   r1, r4
         	inc   K
         	mov   M1[r3][r3], r3
         	bne   LOOP

END:     	stop
STR:	.string "abcdef"
LENGTH:  	.data 6, -9, 15
K:       	.data 22
M1:      	.mat [2][2] 1, 2, 3, 4
3.	קוד התוכנית, לאחר הפרישה, יישמר בקובץ חדש  .am– כפי שיוסבר בהמשך.
אלגוריתם לדוגמא לקדם אסמבלר:
1.	 קרא את השורה הבאה מקובץ המקור
1.1.	 אם נגמר הקובץ – עבור ל־5 (סיום).
1.2.	אחרת – המשך ל־2.
2.	האם השדה הראשון הוא שם מאקרו שמופיע בטבלת המאקרו?
2.1.	אם כן –
•	החלף את שם המאקרו והעתק במקומו את כל השורות המתאימות מהטבלה לקובץ.
•	חזור ל־1.
2.2.	אם לא – המשך ל-4.
3.	האם השדה הראשון הוא "mcro" (תחילת הגדרת מאקרו)?
3.1.	אם לא – עבור ל־4.
3.2.	אם כן
•	 הדלק דגל "יש mcro"
•	הכנס לטבלת המאקרו את שם המאקרו החדש (למשל a_mc)
•	עבור ל־4.
4.	קרא את השורה הבאה מקובץ המקור.
4.1.	אם נגמר הקובץ – עבור ל־5.
4.2.	אחרת –
4.2.1.	אם דגל "יש mcro" דולק:
4.2.1.1.	האם זוהתה תווית "mcroend"?
•	 אם כן:
 - מחק את השורה מהקובץ.
 - כבה את דגל "יש mcro"
 - חזור ל־1.
•	אם לא:
 - הכנס את השורה לטבלת המאקרו.
 - מחק את השורה מהקובץ.
 - חזור ל־4.
4.2.2.	אם דגל ""יש mcro" כבוי  – חזור ל־1.
5.	סיום: שמור את הקובץ עם המאקרואים הפרושים.


הסבר קצר על שני המעברים:
•	נניח שקטע קוד המובא כדוגמה בשלב קדם האמסבלר (הוראה ונתונים) ייטען בזיכרון החל ממען 100 (בבסיס 10).
•	האסמבלר מחזיק טבלה שבה רשומים כל שמות הפעולה של ההוראות והקודים הבינאריים
המתאימים להם (כמובן שאנחנו צריכים לבנות את טבלה זאת ואת התרגום שלה כפונקציה כדי שנוכל להשתמש בה), ולכן שמות הפעולות ניתנים להמרה לבינארי בקלות. כאשר נקרא שם פעולה,
אפשר פשוט לעיין בטבלה ולמצוא את הקוד הבינארי (פונקציה שיש לבנות)
•	כדי לבצע המרה לבינארי של אופרנדים שכתובים בשיטות מיעון המשתמשות בסמלים (תוויות), יש
צורך לבנות טבלה המכילה את ערכי כל הסמלים. אולם בהבדל מהקודים של הפעולות, הידועים מראש, הרי המענים בזיכרון עבור הסמלים שבשימוש בתוכנית אינם ידועים, עד אשר תוכנית המקור נסרקה כולה ונתגלו כל הגדרות הסמלים (רק אז נוכל להקצות להם מקום בזיכרון).
•	למשל, בקוד לדוגמה למעלה, האסמבלר אינו יכול לדעת שהסמל END משויך למען 121 (עשרוני), אלא רק לאחר שיקרא את כל שורות התוכנית.
•	לכן מפרידים את הטיפול של האסמבלר בסמלים לשני שלבים. בשלב הראשון בונים טבלה של כל
הסמלים, עם הערכים המספריים המשוייכים להם, ובשלב השני מחליפים את כל הסמלים המופיעים באופרנדים של הוראות התוכנית בערכיהם המספריים.
•	הביצוע של שני שלבים אלה כרוך בשתי סריקות (הנקראות "מעברים") של קובץ המקור:
1.	במעבר הראשון נבנית טבלת סמלים בזיכרון ובה לכל סמל שבתוכנית המקור משוייך ערך מספרי, שהוא מען בזיכרון. בדוגמה של הקוד, טבלת הסמלים לאחר מעבר ראשון תהיה:
ערך (בסיס עשרוני)	סמל
100	MAIN
107	LOOP
121	END
122	STR
129	LENGTH
132	K
133	1M
2.	במעבר השני נעשית ההמרה של קוד המקור לקוד מכונה. בתחילת המעבר השני צריכים הערכים של הסמלים להיות כבר ידועים.
לתשומת לב: תפקיד האסמבלר, על שני המעברים שלו, לתרגם קובץ מקור לקוד בשפת מכונה. בגמר פעולת האסמבלר, התכנית טרם מוכנה לטעינה לזיכרון לצורך ביצוע. קוד המכונה חייב לעבור לשלבי הקישור והטעינה, ורק לאחר מכן לשלב הביצוע (שלבים אלו אינם חלק מהממ"ן)
המעבר הראשון :
עקרונות:
1.	במעבר הראשון נדרשים כללים כדי לקבוע מען שישויך לכל סמל. 
2.	העיקרון הבסיסי הוא לספור את המקומות בזיכרון אותם תופסות ההוראות. 
3.	אם כל הוראה תישא בזיכרון למקום העוקב להוראה הקודמת, תציין ספירה כזאת את מען ההוראה הבאה. 
4.	הספירה נעשית על ידי האסמבלר ומוחזקת במונה ההוראות (IC) 
5.	ערכו ההתחלתי של IC הוא 100 (עשרוני), ולכן קוד המכונה של ההוראה הראשונה נבנה כך שייטען בזיכרון החל ממען 100. 
6.	ה־IC  מתעדכן בכל שורת הוראה המקצה מקום בזיכרון. 
7.	לאחר שהאסמבלר קובע מהו אורך ההוראה, ה־IC  מוגדל במספר התאים (מילים) הנתפסים על ידי ההוראה, וכך הוא מצביע על התא הפנוי הבא.
8.	כאמור, כדי לקודד את ההוראות בשפת מכונה, מחזיק האסמבלר טבלה, שיש בה קוד מתאים לכל שם פעולה. בזמן התרגום מחליף האסמבלר כל שם פעולה בקוד שלה, וכן כל אופרנד מוחלף בקידוד המתאים, אך פעולת ההחלפה היא אינה כה פשוטה. 
9.	ההוראות משתמשות בשיטות מיעון מגוונות לאופרנדים ואותה פעולה יכולה לקבל משמעויות שונות, בכל אחת משיטות המיעון, ולכן יתאימו לה קידודים שונים לפי שיטות המיעון. 
10.	לדוגמה, פעולה ההזזה MOV יכולה להתייחס להעתקת תוכן תא זיכרון לרגיסטר, או להעתקת תוכן רגיסטר לרגיסטר אחרת, וכן הלאה. לכל אפשרות כזאת של
MOV  עשוי להתאים קידוד שונה.
11.	על האסמבלר לסרוק את שורת ההוראה בשלמותה, ולהחליט לגבי הקידוד לפי האופרנדים. 
12.	בדרך כלל מתחלק הקידוד לשדה של שם הפעולה (opcode שמקודד בסיביות 6-9), ושדות נוספים המכילים מידע לגבי שיטות המיעון (סיביות 2-5 המכילות קידודים של אופרנד היעד והמקור)
13.	כל השדות יחד דורשים מילה אחת או יותר בקוד המכונה.
14.	כאשר נתקל האסמבלר בתווית המופיעה בתחילת השורה, הוא יודע שלפניו הגדרה של תווית, ואז הוא משייך לה מען – תוכנו הנוכחי של הIC , וכך מקבלת כל תווית את המען המתאים לה בעת ההגדרה.
15.	תוויות אלה מוזנות לטבלת הסמלים, המכילה בנוסף לשם התווית גם את המען שניתן לה ומאפיינים נוספים (כמו האם היא שייכת להוראה או נתונים – code\data)
16.	כאשר תהיה התייחסות לתווית באופרנד של הוראה כלשהי, יוכל האסמבלר לשלוף את המען המתאים מטבלת הסמלים.
17.	הוראה יכולה להתייחס גם לסמל שטרם הוגדר עד כה בתכנית, אלא יוגדר רק בהמשך התכנית.
18.	לדוגמה, הוראת הסתעפות למען שמוגדר על ידי התווית A שמופיעה רק בהמשך הקוד:
bne   A
.
……
19.	כאשר מגיע האסמבלר לשורת ההסתעפות (bne A) הוא טרם נתקל בהגדרת התווית A וכמובן לא יודע את המען המשוייך לתווית. לכן האסמבלר לא יכול לבנות את הקידוד הבינארי של האופרנד A. נראה בהמשך כיצד נפתרת בעיה זו.
20.	בכל מקרה , תמיד אפשר לבנות במעבר הראשון את הקידוד הבינארי המלא של המילה הראשונה של כל הוראה, את הקידוד הבינארי של מילת-המידע הנוספת של אופרנד מיידי, או רגיסטר , וכן את הקידוד הבינארי של כל הנתונים (המתקבלים מההנחיות .mat, .string, .data)
אלגוריתם שלדי למעבר הראשון:
אנו מחלקים את קוד המכונה לשני אזורים- אזור ההוראות (code) ואזור הנתונים(data) .  
לכל אזור יש מונה משלו, אותם נסמן: 
 - ICמונה ההוראות (Instruction-Counter) 
DC - מונה הנתונים (Data-Counter) 
נבנה את קוד המכונה כך שיתאים לטעינה לזיכרון החל מכתובת 100 .
בכל מעבר מתחילים לקרוא את קובץ המקור מהתחלה.
1.	אתחל 0  IC , ואתחל 0  DC
2.	קרא את השורה הבאה מקובץ המקור. אם נגמר הקובץ – עבור ל17.
3.	האם השדה הראשון בשורה הוא סמל? אם לא עבור ל-5
4.	הדלק דגל "יש הגדרת סמל"
5.	האם זוהי הנחיה לאחסון נתונים (כלומר האם הנחיית .data או .string או .mat)? אם לא – עבור ל-8
6.	אם יש הגדרת סמל (תווית), הכנס אותו לטבלת הסמלים עם המאפיין .data , ערכו יהיה DC. (אם הסמל כבר נמצא בטבלה יש להודיע על שגיאה)
7.	זהה את סוג הנתונים. קודד אותם בזיכרון, ועדכן את מונה הנתונים DC בהתאם לאורכם. חזור ל-2.
8.	האם זוהי הנחיית .extern או הנחיית .entry ?  אם לא – עבור ל-11
9.	אם זוהי הנחיית .entry , חזור ל2. (ההנחייה תטופל במעבר השני)
10.	אם זוהי הנחיית .extern , הכנס את הסמל המופיע כאופרנד של ההנחיה לתוך טבלת הסמלים עם הערך 0, ועם המאפיין external. חזור ל2.
11.	זוהי שורת הוראה. אם יש הגדרת סמל, הכנס אותו לטבלת הסמלים עם המאפיין code. ערכו של הסמל יהיה IC (אם הסמל כבר נמצא בטבלה יש להודיע על שגיאה).
12.	חפש את שם הפעולה בטבלת שמות הפעולות, ואם לא נמצא, אז הודע על שגיאה בשם ההוראה.
13.	נתח את מבנה האופרנדים של ההוראה וחשב מהו מספר המילים הכולל שתופסת ההוראה בקוד המכונה (נקרא למספר זה L)
14.	 בנה כעת את הקוד הבינארי של המילה הראשונה של ההוראה, ושל כל מילת מידע נוספת המקודדת אופרנד במיעון מיידי.
15.	שמור את הערכים IC ו- L יחד עם נתוני קוד המכונה של ההוראה.
16.	עדכן L + IC  IC וחזור ל2.
17.	קובץ המקור נקרא בשלמותו. אם נמצאו שגיאות במעבר הראשון של ההוראה, עצור כאן.
18.	שמור את הערכים הסופיים של IC ושל DC (נקרא להם ICF ו-DCF). נשתמש בהם לבניית קבצי הפלט לאחר המעבר השני.
19.	עדכן בטבלת הסמלים את ערכו של כל סמל המאופיים כdata , ע"י הואספת הערך ICF (ראו הסבר לכך בהמשך)
20.	התחל מעבר שני. 
המעבר השני:
עקרונות:
1.	ראינו שבמעבר הראשון, האסמבלר אינו יכול לבנות את קוד המכונה של האופרנדים המשתמשים בסמלים שעדיין לא הוגדרו. רק לאחר שהאסמבלר עבר על כל התוכנית, כך שכל הסמלים נכנסו כבר לטבלת הסמלים, יכול האסמבלר לתרגם את קוד המכונה של כל האופרנדים.
2.	לשם כך עובר האסמבלר מעבר נוסף (מעבר שני) על כל קובץ המקור, ומעדכן את קוד המכונה של האופרנדים המשתמשים בסמלים, באמצעות ערכי הסמלים מטבלת הסמלים.
3.	בסוף המעבר השני, תהיה התוכנית מתורגמת בשלמותה לקוד מכונה.

הפרדת הוראות ונתונים
1.	בתוכנית מבחינים בין שני סוגים של תוכן: הוראות ונתונים. יש לארגן את קוד המכונה כך שתהיה הפרדה בין הנתונים וההוראות. הפרדת ההוראות והנתונים לקטעים שונים בזיכרון היא שיטה עדיפה על פני הצמדה של הגדרות נתונים להוראות המשתמשות בהן.
2.	אחת הסכנות הטמונות באי הפרדת ההוראות מהנתונים היא, שלעיתים עלול המעבד, בעקבות שגיאה לוגית בתוכנית, לנסות "לבצע" את הנתונים כאילו היו הוראות חוקיות. למשל, שגיאה שיכולה לגרום לתופעה כזאת הסתעפות לא נכונה. התכנית כמובן לא תעבוד נכון, אך לרוב הנזק הוא יותר חמור, כי נוצרת חריגת חומרה ברגע שהמעבד .מבצע פעולה שאינה חוקית
3.	האסמבלר שלנו חייב להפריד, בקוד המכונה שהוא מייצר, בין קטע הנתונים לקטע ההוראות.
כלומר, בקובץ הפלט (בקוד המכונה) תהיה הפרדה של הוראות ונתונים לשני קטעים נפרדים, ואילו בקובץ הקלט אין חובה שתהיה הפרדה כזו. בהמשך מתואר האלגוריתם של האסמבלר, ובו פרטים כיצד לבצע את ההפרדה.

גילוי שגיאות בתוכנית המקור
1.	הנחת המטלה היא שאין שגיאות בהגדרות המאקרו, ולכן שלב קדם האסמבלר אינו מכיל שלב גילוי שגיאות. אין גם צורך לבדוק שגיאות בפתיחת\סגירת המאקרו (למשל אם המאקרו לא מסתיים – ניתן להניח שהנ"ל תקין). לעומת זאת, האסמבלר אמור לגלות ולדווח על שגיאות בתחביר של תוכנית המקור, כמו פעולה שאינה קיימת, מספר אופרנדים שגוי, סוג אופרנד שאינו מתאים לפעולה, שם רגיסטר לא קיים, ועוד שגיאות אחרות. כמו כן מוודא האסמבלר שכל סמל מוגדר פעם אחת בדיוק.
2.	מכאן, שכל שגיאה המתגלה על ידי האסמבלר נגרמת (בדרך כלל) על ידי שורת קלט מסוימת.
3.	לדוגמה, אם מופיעים שני אופרנדים שנאמרו להיות בה רק אופרנד יחד, האסמבלר ייתן הודעת שגיאה בנוסח "יותר מדי אופרנדים".
1.	הערה: אם יש שגיאה בקוד האסמבלי בגוף מאקרו, הרי שגיאה זו יכולה להופיע ולהתגלות שוב ושוב בכל מקום בו נפרש המאקרו. נשים לב שכאשר האסמבלר בודק שגיאות, כבר לא ניתן לחזור שזה קוד שנפרש ממאקרו, כך שלא ניתן לחסוך גילויי שגיאה כפולים.
2.	האסמבלר ידפיס את הודעות השגיאה אל הפלט הסטדנרטי stdout
3.	בכל הודעת שגיאה יש לציין גם את מספר השורה בקובץ המקור בה זוהתה השגיאה (מניין השורות בקובץ מתחיל ב-1)
4.	לתשומת לב: האסמבלר אינו עוצר את פעולתו אחרי שנמצאה השגיאה הראשונה, אלא ממשיך לעבור על הקלט כדי לגלות שגיאות נוספות, ככל שישנן. כמובן שאין כל טעם ליצור את קבצי הפלט אם התגלו שגיאות (ממילא אי אפשר להשלים את קוד המכונה).
5.	הטבלה הבאה מפרטת מה הן שיטות המיון החוקיות, עבור אופרנד המקור ואופרנד היעד של ההוראות השונות המוגדרות בשפה הנתונה:
Opcode	שם ההוראה	שיטות מיעון חוקיות עבור אופרנד המקור	שיטות מיעון חוקיות עבור אופרנד היעד
0	mov	0,1,2,3	1,2,3
1	cmp	0,1,2,3	0,1,2,3
2	add	0,1,2,3	1,2,3
3	sub	0,1,2,3	1,2,3
4	lea	1,2	1,2,3
5	clr	אין אופרנד מקור	1,2,3
6	not	אין אופרנד מקור	1,2,3
7	inc	אין אופרנד מקור	1,2,3
8	dec	אין אופרנד מקור	1,2,3
9	jmp	אין אופרנד מקור	1,2,3
10	bne	אין אופרנד מקור	1,2,3
11	jsr	אין אופרנד מקור	1,2,3
12	red	אין אופרנד מקור	1,2,3
13	prn	אין אופרנד מקור	0,1,2,3
14	rts	אין אופרנד מקור	אין אופרנד יעד
15	stop	אין אופרנד מקור	אין אופרנד יעד


אלגוריתם שלדי למעבר השני:
1.	קרא את השורה הבאה מקובץ המקור. אם נגמר קובץ המקור, עבור ל־7.
2.	אם השדה הראשון בשורה הוא סמל (תווית), דלג עליו.
3.	האם זוהי הנחיית .data, .mat, .string או ? .extern אם כן, חזור ל־1.
4.	האם זוהי הנחית ? .entry  אם לא, עבור ל־6.
5.	הוסף בטבלת הסמלים את המאפיין entry למאפייני הסמל המופיע כאופרנד של ההנחיה (אם הסמל לא נמצא בטבלת הסמלים,  יש להודיע על שגיאה). חזור ל־1.
6.	השלם את הקידוד הבינארי של מילות המידע של האופרנדים, בהתאם לשיטות המיעון שבשימוש. לכל אופרנד בקוד המקור המכיל סמל, מצא את ערכו של הסמל בטבלת הסמלים (אם הסמל לא מופיע בטבלה יש להודיע על שגיאה). אם הסמל מאופיין external, הוסף את כתובת מילת-המידע הרלוונטית לרשימת מילות-מידע שמתייחסות לסמל חיצוני. לפי הצורך, לחישוב הקידוד והכתובות, אפשר להיעזר בערכים IC ו-L של ההוראה, כפי שנשמרו במעבר הראשון. חזור ל־1.
7.	קובץ המקור נקרא בשלמותו. אם נמצאו שגיאות במעבר השני, עצור כאן.
בנה את קבצי הפלט (פרטים נוספים במשך).

הדגמת האלגוריתמים על תוכנית:
התוכנית הגולמית:
MAIN:      	   mov   M1[r2][r7], LENGTH
   		   add   r2, STR
LOOP:   	   jmp   END
         	   prn   #-5
  		  mcro  a_mc
  	             	  mov   M1[r3][r3], r3
  bne   LOOP
         	  mcrend
         	   sub   r1, r4
         	   inc   K
		   a_mc
END:          	   stop
STR:   	  .string "abcdef"
LENGTH: 	 .data 6, -9, 15
K: 	         	  .data 22
M1:       	 .mat [2][2] 1, 2, 3, 4

פרישת המאקרואים: קדם אסמבלר
MAIN:      	   mov   M1[r2][r7], LENGTH
   		   add   r2, STR
LOOP:   	   jmp   END
         	   prn   #-5
         	   sub   r1, r4
         	   inc   K
		  mov   M1[r3][r3], r3
  bne   LOOP
END: 	  stop   
STR:   	  .string "abcdef"
LENGTH: 	 .data 6, -9, 15
K: 	         	  .data 22
M1:       	 .mat [2][2] 1, 2, 3, 4

האסמבלר עובר על התוכנית בשלב קדם אסמבלר ופורש את כל המקרואים לתוך קובץ .am.
אם התהליך מסתיים בהצלחה , ניתן לעבור לשלב הבא.
אחרת – יש להציג את השגיאות ולא לייצר קבצים.

המעבר ראשון:
במעבר הראשון על הקוד הנתון על האסמבלר:
1.	לבנות את טבלת הסמלים
2.	לקודד את כל הנתונים
3.	לקודד את המילה הראשונה של כל הוראה.
4.	לקודד מילות מידע נוספות של כל הוראה, ככל שקידוד זה אינו תלוי בערך של סמל.
את החלקים שעדיין לא "מתורגמים" נשאיר כמו שהם (בדוגמה זו יסומנו בסימן שאלה כדי להבהיר שהם שייכים למעבר השני). נניח שהקוד ייטען החל מהמען 100 (בבסיס 10)
הקידוד הראשוני ייראה כך:


Binary machine code	Operands	Instruction	Base 4 Address	Decimal Address	Label
0000-10-01-00
?
0010-0111-00
?	M1[r2][r7],LENGTH
M1 כתובת של
קידוד אוגרי האינדקסים במטריצה
LENGTH כתובת	mov	1210
1211
1212
1213	0100
0101
0102
0103	MAIN:
0010-11-01-00
0010-0000-00
?	r2, STR
קידוד מספר האוגר
STR כתובת של	add
	1220
1221
1222	0104
0105
0106	
1001-00-01-00
?	END
END כתובת של	jmp	1223
1230	0107
0108	LOOP:
1100-00-00-00
11111011-00	#-5
המספר 5-	prn	1231
1232	0109
0110	
0011-11-11-00
0001-0100-00	r1,r4
קידודי מספרי האוגרים	sub	1233
1300	0111
0112	
0111-00-01-00
?	K
K כתובת של	inc	1301
1302	0113
0114	
0000-10-11-00
?
0011-0011-00
0000-0011-00	M1[r3][r3],r3
M1 כתובת של
קידוד אוגרי האינדקסים במטריצה
קידוד מספר האוגר של היעד	mov	1303
1310
1311
1312	0115
0116
0117
0118	
1010-00-01-00
?	LOOP
LOOP כתובת של	bne	1313
1320	0119
0120	
1111-00-00-00		stop	1321	0121	END:
0001100001	“abcdef”	.string	1322	0122	STR:
0001100010			1323	0123	
0001100011			1330	0124	
0001100100			1331	0125	
0001100101			1332	0126	
0001100110			1333	0127	
0000000000			2000	0128	
0000000110
1111110111
0000001111	6,-9,15	.data	2001
2002
2003	0129
0130
0131	LENGTH:
0000010110	22	.data	2010	0132	K:
0000000001
0000000010
0000000011
0000000100	[2][2] 1,2,3,4	.mat	2011
2012
2013
2020	0133
0134
0135
0136	M1:

איפיון הסמל	ערך (בבסיס עשרוני)	סמל
code	100	MAIN
code	107	LOOP
code	121	END
data	122	STR
data	129	LENGTH
data	132	K
-	133	M1
טבלת הסמלים לאחר המעבר הראשון היא:






המעבר השני:
כעת, באמצעות טבלת הסמלים, ניתן להשלים את הקידוד החסר (במילים המסומנות ב"?") במעבר השני.
הערה: האסמבלר בונה קוד מכונה כך שיתאים לטעינה לזיכרון החל מכתובת 100 (עשרוני). אם הטעינה בפועל (לצורך הרצת התוכנית) תהיה לכתובת אחרת, יידרשו תיקונים בקוד הבינארי בשלב הטעינה, שיוכנסו בעזרת מידע נוסף שהאסמבלר מכין בקבצי הפלט. הטבלה לאחר המעבר השני תיראה כך:
Binary machine code	Operands	Instruction	Base 4 Address	Decimal Address	Label
0000-10-01-00
10000101-10
0010-0111-00
10000001-10	M1[r2][r7],LENGTH
M1 כתובת של
קידוד אוגרי האינדקסים במטריצה
LENGTH כתובת	mov	1210
1211
1212
1213	0100
0101
0102
0103	MAIN:
0010-11-01-00
0010-0000-00
01111010-10	r2, STR
קידוד מספר האוגר
STR כתובת של	add
	1220
1221
1222	0104
0105
0106	
1001-00-01-00
01111001-10	END
END כתובת של	jmp	1223
1230	0107
0108	LOOP:
1100-00-00-00
11111011-00	#-5
המספר 5-	prn	1231
1232	0109
0110	
0011-11-11-00
0001-0100-00	r1,r4
קידודי מספרי האוגרים	sub	1233
1300	0111
0112	
0111-00-01-00
10000100-10	K
K כתובת ש	inc	1301
1302	0113
0114	
0000-10-11-00
10000101-10
0011-0011-00
0000-0011-00	M1[r3][r3],r3
M1 כתובת של
קידוד אוגרי האינדקסים במטריצה
קידוד מספר האוגר של היעד	mov	1303
1310
1311
1312	0115
0116
0117
0118	
1010-00-01-00
01101011-10	LOOP
LOOP כתובת של	bne	1313
1320	0119
0120	
1111-00-00-00		stop	1321	0121	END:
0001100001	“abcdef”	.string	1322	0122	STR:
0001100010			1323	0123	
0001100011			1330	0124	
0001100100			1331	0125	
0001100101			1332	0126	
0001100110			1333	0127	
0000000000			2000	0128	
0000000110
1111110111
0000001111	6,-9,15	.data	2001
2002
2003	0129
0130
0131	LENGTH:
0000010110	22	.data	2010	0132	K:
0000000001
0000000010
0000000011
0000000100	[2][2] 1,2,3,4	.mat	2011
2012
2013
2020	0133
0134
0135
0136	M1:

בסוף המעבר השני, אם לא נתגלו שגיאות, האסמבלר בונה את קבצי הפלט, שמכילים את הקוד הבינארי ומידע נוסף עבור שלבי הקישור והטעינה.
קבצי קלט וקבצי פלט של האסמבלר:
•	בהפעלה של האסמבלר, יש להעביר אליו באמצעות ארגומנטים של שורת הפקודה (command line arguments) רשימה של שמות קבצי מקור (אחד או יותר). אלו הם קבצי טקסט, ובהם תוכניות בתחביר של שפת האסמבלי שהוגדרה בממ"ן זה.
•	האסמבלר פועל על כל קובץ מקור בנפרד, ויוצר עבורו את קבצי הפלט הבאים:
1.	קובץ am - המכיל את קובץ המקור לאחר שלב קדם האסמבלר (לאחר פרישת המקרואים)
2.	קובץ object – המכיל את קוד המכונה (יקבל כקלט את קובץ הam, והפלט יהיה הקוד אחרי שני המעברים)
3.	קובץexternals  ובו פרטים על כל המקומות (הכתובות) בקוד המכונה בהם יש מילת מידע שמקודדת ערך של סמל שהוצהר כחיצוני (סמל שהופיע כאופרנד של הנחיית .extern, ומאופיין בטבלת הסמלים כ-external)
4.	קובץ entries ובו פרטים על כל סמל שמוצהר כנקודת כניסה (סמל שהופיע כאופרנד של הנחיית .entry ומאופיין בטבלת הסמלים כentry)
•	אם אין בקובץ המקור אף הנחיית .extern אז האסמבלר לא יוצר את קובץ הפלט מסוג externals, ואם אין בקובץ המקור אף הנחיית .entry אז האסמבלר לא יוצר את קובץ הפלט מסוג entries
•	שמות קבצי המקור חייבים להיות עם הסיומת .as (למשל השמות x.as, hello.as, y.as הם חוקיים). העברת שמות הקבצים הללו כארגומנטים לאסמבלר נעשית ללא ציון הסיומת.
•	לדוגמה: נניח שתוכנית האסמבלר שלנו נקראת assembler , אז שורת הפקודה: assembler x y hello  תריץ על האסמבלר את הקבצים הבאים:hello.as, x.as, y.as
•	שמות קבצי הפלט מבוססים על שם קובץ הקלט כפי שהופיע בשורת הפקודה, בתוספת הסיומת המתאימה: 
1.	הסיומת .am עבור קובץ לאחר פרישת מאקרו
2.	הסיומת .ob עבור קובץ ה- object (קוד המכונה)
3.	הסיומת .ent עבור קובץ הentries
4.	הסיומת .ext עבור קובץ ה-externals
5.	לדוגמה: בהפעלת האסמבלר באמצעות שורת הפקודה assembler x, יווצר קובץ פלט x.ob , וכן קבצי פלט x.ext ו- x.ent (רק במידה ואכן יש הנחיות .extern או  .entry בקובץ המקור). אם אין מאקרו בקובץ המקור, אז הקובץ ".am" יהיה זהה לקובץ המקור  ".as"  

פורמט קובץ הobject – 
2.	קובץ זה מכיל את תמונת הזיכרון של קוד המכונה בשני חלקים: תמונת ההוראות הראשונה ואחריה ובצמוד תמונת הנתונים.
3.	האסמבלר מקודד את ההוראות כך שבתמונת ההוראות תתאים לטעינה החל מכתובת 100 (עשרוני) בזיכרון.
4.	נשים לב שרק בסוף המעבר הראשון יודעים מהו הגודל הכולל של תמונת ההוראות.
5.	מכיוון שתמונת הנתונים נמצאת אחרי תמונת ההוראות, גודל תמונת ההוראות משפיע על הכתובות בתמונת הנתונים. זו הסיבה שבגללה היה צורך לעדכן בטבלת הסמלים בסוף המעבר הראשון את ערכי הסמלים המאופיינים כdata -  (כזכור , בצעד 10 הוספנו לכל כזה את הערך של ICF) .
6.	במעבר השני , בהשלמת הקידוד של מילות המידע, משתמשים בערכים המעודכנים של הסמלים, המותאמים למבנה המלא והסופי של תמונת הזיכרון.
7.	כעת האסמבלר יכול לכתוב את תמונת הזיכרון בשלמותה לתוך קובץ הפלט (קובץ הobject -). עקרונית, קובץ object מכיל את תמונת הזיכרון שתוארה כאן. 
8.	קובץ object מורכב משורות של טקסט. השורה הראשונה מכילה שני מספרי: אורך כולל של קטע ההוראות (במילות זיכרון) ואורך כולל של קטע הנתונים (במילות זיכרון).
9.	השורות הבאות מתארות את תוכן הזיכרון – בכל שורה שני מספרים : כתובת של מילה בזיכרון ותוכן המילה.
10.	כל המספרים בקובץ object הם בבסיס 4 "ייחודי" (ראו הגדרה לעיל).
11.	בהמשך מופיע קובץ object לדוגמא בשם ps.ob המתאים לקובץ המקור ps.as
12.	עבור כל תא זיכרון המכיל הוראה (ולא נתונים) מופיע בקובץ object מידע עבור תוכנית הקישור – מידע זה ניתן על ידי 2 הסיביות הימניות של הקידוד (שדה הE,R,A) :
1.	האות 'A' (קיצור של absolute) – מציינת שתוכן התא אינו תלוי במקום בזיכרון בו ייטען בפועל קוד המכונה של התכנית בזמן ביצועה (למשל מילה המכילה אופרנד מיידי)
2.	האות 'R' (קיצור של relocateable)  - מציינת שתוכן התא כן תלוי במקום בזיכרון שבו ייטען בפועל קוד המכונה של התכנית בעת ביצועה. לכן יש לעדכן את תוכן התא בשלב הטעינה , על ידי הוספת היסט (offset) מתאים (היסט זה הינו המען בו תטען המילה הראשונה של התוכנית). במקרה כזה 2 הסיביות הימניות יכילו את הערך 10.
3.	האות 'E' (קיצור של external) – מציינת שתוכן התא תלוי בערכו של סמל חיצוני (external) וכי רק הזמן הקישור ניתן יהיה להכניס לתא את הערך המתאים. במקרה כזה 2 הסיביות הימניות יכילו את הערך 01.

פורמט קובץ הentries -  
1.	קובץ ה- entries בנוי משורות טקסט.
2.	כל שורה מכילה שם של סמל שהוגדר כ – entry ואת ערכו, כפי שנמצא בטבלת הסמלים. 
3.	הערכים כולם בבסיס 4 הייחודי.
4.	לדוגמא עבור קובץ המקור ps.as במידה ויידרש, יווצר קובץ entries שייקרא  ps.ent

פורמט קובץ הexternals -  
1.	קובץ ה – externals בנוי אף הוא משורות טקסט.
2.	כל שורה מכילה שם של סמל שהוגדר external, וכתובת בקוד המכונה בה יש קידוד של אופרנד המתייחס לסמל זה.
3.	כמובן שייתכן ויש מספר כתובות בקוד המכונה בהם מתייחסים לאותו מסל חיצוני. לכל התייחסות כזו תהיה שורה נפרדת בקובץ הexternals - .
4.	הכתובות מיוצגות בבסיס 4 הייחודי.
5.	לתשומת לב: ייתכן ויש מספר כתובות בקוד המכונה בהם מילות – המידע מתייחסות לאותו סמל חיצוני. לכל כתובת כזו תהיה שורה נפרדת בקובץ ה- externals

הדגמה לקבצי פלט שמייצר האסמבלר
קלט – קובץ מקור בשם ps.as:

; file ps.as
.entry LOOP
.entry LENGTH
.extern L3
.extern W
MAIN:      	   mov   M1[r2][r7], LENGTH
   		   add   r2, STR
LOOP:   	   jmp   END
         	   prn   #-5
         	   sub   r1, r4
         	   inc   K
		  mov   M1[r3][r3], r3
  bne   LOOP
END: 	  	  stop   
STR:   	  	  .string "abcdef"
LENGTH: 	  .data 6, -9, 15
K: 	         	  .data 22
M1:       		 .mat [2][2] 1, 2, 3, 4

1.	בהינתן ואין מקרואים, קובץ ה.am -  יהיה זהה לקובץ המקור הראשוני .as
2.	טבלת הקידוד הבינארי המלא שמתקבל מקובץ המקור, כפי שנבנה במעבר הראשון והשני:

Binary machine code	Operands	Instruction	Base 4 Address	Decimal Address	Label
0000-10-01-00
10000101-10
0010-0111-00
10000001-10	M1[r2][r7],LENGTH
M1 כתובת של
קידוד אוגרי האינדקסים במטריצה
LENGTH כתובת	mov	1210
1211
1212
1213	0100
0101
0102
0103	MAIN:
0010-11-01-00
0010-0000-00
01111010-10	r2, STR
קידוד מספר האוגר
STR כתובת של	add
	1220
1221
1222	0104
0105
0106	
1001-00-01-00
01111001-10	END
END כתובת של	jmp	1223
1230	0107
0108	LOOP:
1100-00-00-00
11111011-00	#-5
המספר 5-	prn	1231
1232	0109
0110	
0011-11-11-00
0001-0100-00	r1,r4
קידודי מספרי האוגרים	sub	1233
1300	0111
0112	
0111-00-01-00
10000100-10	K
K כתובת ש	inc	1301
1302	0113
0114	
0000-10-11-00
10000101-10
0011-0011-00
0000-0011-00	M1[r3][r3],r3
M1 כתובת של
קידוד אוגרי האינדקסים במטריצה
קידוד מספר האוגר של היעד	mov	1303
1310
1311
1312	0115
0116
0117
0118	
1010-00-01-00
01101011-10	LOOP
LOOP כתובת של	bne	1313
1320	0119
0120	
1111-00-00-00		stop	1321	0121	END:
0001100001	“abcdef”	.string	1322	0122	STR:
0001100010			1323	0123	
0001100011			1330	0124	
0001100100			1331	0125	
0001100101			1332	0126	
0001100110			1333	0127	
0000000000			2000	0128	
0000000110
1111110111
0000001111	6,-9,15	.data	2001
2002
2003	0129
0130
0131	LENGTH:
0000010110	22	.data	2010	0132	K:
0000000001
0000000010
0000000011
0000000100	[2][2] 1,2,3,4	.mat	2011
2012
2013
2020	0133
0134
0135
0136	M1:

קובץ object ps.ob – 
כל תוכן הקובץ מיוצג במספרים בבסיס 4 הייחודי.
הערה: שורת הכותרת אינה חלק מהקובץ, ונועדה להבהרה בלבד.

Base 4 address 	Base 4 code
bbc dd 
bcba			aacba
bcbb			cabbc
bcbc			acbda
bcbd			aaaab
bcca			acdba
bccb			acaaa
bccc			bdccc
bccd			cbaba
bcda			aaaab
bcdb			daaaa
bcdc			ddcda
bcdd			addda
bdaa			abbaa
bdab			bdaba
bdac			cabac
bdad			aacda
bdba			cabbc
bdbb			adada
bdbc			aaada
bdbd			ccaba
bdca			aaaab
bdcb			ddaaa
bdcc			abcab
bdcd			abcac
bdda			abcad
bddb			abcba
bddc			abcbb
bddd			abcbc
caaa			aaaaa
caab			aaabc
caac			dddbd
caad			aaadd
caba			aaabbc
cabb			aaaab
cabc			aaaac
cabd			aaaad
caca			aaaba




קובץ ps.ent:

LOOP		bccd
LENGTH	caab

אם בקובץ המקור אין הנחיות .entry – לא יווצר קובץ .entries
אין ליצור קובץ .ent שנשאר ריק
אין חשיבות לסדר השורות בקובץ – כל שורה עומדת בפני עצמה.

קובץ ps.ext:

W	bcbd
W	bcda
L3	bdca
אם בקובץ המקור אין הנחיות .extern – לא יווצר קובץ .ext
אין ליצור קובץ .ext שנשאר ריק
אין חשיבות לסדר השורות בקובץ – כל שורה עומדת בפני עצמה.


הנחיות נוספות לפרוייקט
1.	כדי להקל במימוש האסמבלר – ניתן להניח גודל מקסימלי של אורך התוכנית המתורגמת.
2.	לפיכך – יש אפשרות להשתמש במערכים לאחסון תמונת קוד המכונה בלבד. עבור כל מבנה נתונים אחר (כמו טבלת הסמלים או טבת המקרואים) יש לממש באופן יעיל וחסכוני (למשל באמצעות רשימה מקושרת והקצאת זיכרון דינאמי)
3.	ממש המשתמש באסמבלר יהיה אך ורק באמצעות שורת הפקודה. בפרט, שמות קבצי המקור יועברו לתכנית האסמבלר כארגומנטים בשורת הפקודה. אין להוסיף תפריטי קלט אינטראקטיביים, חלונות גרפיים למיניהם וכו'.
4.	יש להקפיד לחלק את מימוש האסמבלר למספר מודולים (קבצים בשפת C) לפי משימות. אין לרכז משימות מסוגים שונים במודול יחיד. 
5.	מומלץ לחלק למודולים כגון : מעבר ראשון, מעבר שני, פונקציות עזר (למשל תרגום לבסיס 4 ייחודי, ניתוח תחבירי של שורה וכו'), טבלת הסמלים, מפת הזיכרון, טבלאות קבועות (קודי הפעולה, שיטות המיעון החוקיות לכל פעולה וכד')
6.	יש להקפיד לתעד את המימוש באופן מלא וברור, באמצעות הוראות מפורטות בקוד.
7.	יש לאפשר תווים לבנים עודפים בקובץ הקלט בשפת אסמבלי. למשל, אם בשורת ההוראה יש שני אופרנדים המופרדים הפסיק, אז לפני ואחרי הפסיק מותר שיהיו רווחים וטאבים בכל כמות. בדומה, גם לפני ואחרי שם הפעולה. מותרות גם שורות ריקות. האסמבלר יתעלם מתווים לבנים מיותרים (כלומר ידלג עליהם).
8.	הקלט (קוד האסמבלי) עלול להכיל שגיאות תחביריות. על האסמבלר לגלות ולדווח על כל השורות השגויות בקלט. אין לעצור את הטיפול בקובץ הקלט לאחר גילוי השגיאה הראשונה. יש להדפיס למסך הודעות מפורטות כלל הניתן, כדי שיהיה ניתן להבין מה והיכן השגיאה (מה השגיאה ואיזה שורה בקוד היא מופיעה בה). כמובן שאם קובץ הקלט מכיל שגיאות – אין טעם להפיק עבורו את קבצי הפלט (ob, ent, ext).
